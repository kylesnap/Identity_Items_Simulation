library(tidyverse)
library(checkmate)
library(rlang)
library(doRNG)
library(doParallel)
library(data.table)

#' Make cell of simulation parameters
#'
#' @param n Number of observations.
#' @param probs A numeric vector of length 2 representing the probabilities of
#' each state: Pr_M (probability of state M), Pr_W (probability of state W),
#' and Pr_X (probability of state X).
#' @param beta A numeric vector of length 4 representing the coefficients for
#' the linear model: intercept, Z, XW, XX.
#' @param delta A numeric vector of length 2 representing the delta values for
#' each state: D_M (delta for state M), D_W (delta for state W), and D_X
#' (delta for state X).
#' @param sigma Standard deviation of the error term.
#'
#' @return A list containing the simulation parameters.
make_cell <- function(N,
                      Pr_W,
                      Pr_X,
                      Beta_Int = 0,
                      Beta_Z = 0,
                      Beta_XW = 0,
                      Beta_XX = 0,
                      Delta_W = 0,
                      Delta_X = 0,
                      Sigma_E = 1) {
  assert_numeric(
    Pr_W,
    lower = 0,
    upper = 1,
    len = 1,
    any.missing = FALSE
  )
  assert_numeric(
    Pr_X,
    lower = 0,
    upper = 1,
    len = 1,
    any.missing = FALSE
  )
  assert(Pr_W + Pr_X <= 1)
  
  delta <- c(Delta_W, Delta_X)
  assert_numeric(delta, len = 2)
  
  assert_number(Sigma_E, lower = .Machine$double.xmin)
  list(
    "n" = assert_count(N),
    "probs" = c(
      "Pr_M" = 1 - Pr_W - Pr_X,
      "Pr_W" = Pr_W,
      "Pr_X" = Pr_X
    ),
    "beta" = c(
      "Int" = Beta_Int,
      "Z" = Beta_Z,
      "XW" = Beta_XW,
      "XX" = Beta_XX
    ),
    "delta" = c(
      "D_M" = -(Delta_W * Pr_W + Delta_X * Pr_X) / (1 - Pr_W - Pr_X),
      "D_W" = Delta_W,
      "D_X" = Delta_X
    ),
    "sigma" = Sigma_E
  )
}

cell_as_row <- function(cell) {
  list(
    N = cell$n,
    Pr_M = cell$probs["Pr_M"],
    Pr_W = cell$probs["Pr_W"],
    Pr_X = cell$probs["Pr_X"],
    Beta_Int = cell$beta["Int"],
    Beta_Z = cell$beta["Z"],
    Beta_XW = cell$beta["XW"],
    Beta_XX = cell$beta["XX"],
    D_M = cell$delta["D_M"],
    D_W = cell$delta["D_W"],
    D_X = cell$delta["D_X"],
    Sigma_E = cell$sigma
  )
}

#' Make a transition matrix for respondents
#'
#' @param ep_M A numeric vector of length 2 representing the transition
#' probabilities for state M.
#' @param ep_W A numeric vector of length 2 representing the transition
#' probabilities for state W.
#' @param ep_X A numeric vector of length 2 representing the transition
#' probabilities for state X.
#'
#' @return A transition matrix.
make_pmat <- function(row_M, row_W, row_X) {
  assert_numeric(
    row_M,
    lower = 0,
    upper = 1,
    len = 3,
    any.missing = FALSE
  )
  assert_numeric(
    row_W,
    lower = 0,
    upper = 1,
    len = 3,
    any.missing = FALSE
  )
  assert_numeric(
    row_X,
    lower = 0,
    upper = 1,
    len = 3,
    any.missing = FALSE
  )
  assert(sum(row_M) == 1)
  assert(sum(row_W) == 1)
  assert(sum(row_X) == 1)
  matrix(
    c(row_M, row_W, row_X),
    nrow = 3,
    byrow = TRUE,
    dimnames = list(c("X=M","X=W","X=X"), c("V=M","V=W","V=X"))
  )
}

pmat_as_row <- function(pmat) {
  res <- c(t(pmat))
  names(res) <- c("Pr_MM", "Pr_MW", "Pr_MX",
                  "Pr_WM", "Pr_WW", "Pr_WX",
                  "Pr_XM", "Pr_XW", "Pr_XX")
  res
}

#' Generate observations of the Z variable, conditional on X
#'
#' @param X A vector of X values.
#' @param deltas A named numeric vector of mean Z values for each state.
#'
#' @return A vector of observations of the Z variable.
make_z <- function(X, deltas) {
  Z <- numeric(length(X))
  Z[X == 1] <- rnorm(n = sum(X == 1), mean = deltas["D_M"], sd = 1)
  Z[X == 2] <- rnorm(n = sum(X == 2), mean = deltas["D_W"], sd = 1)
  Z[X == 3] <- rnorm(n = sum(X == 3), mean = deltas["D_X"], sd = 1)
  return(Z)
}

make_xv <- function(n, probs, pmat) {
  X <- sample.int(3, size = n, replace = TRUE, prob = probs)
  V <- integer(n)
  V[X == 1] <- sample.int(3, size = sum(X == 1), replace = TRUE, prob = pmat[1,])
  V[X == 2] <- sample.int(3, size = sum(X == 2), replace = TRUE, prob = pmat[2,])
  V[X == 3] <- sample.int(3, size = sum(X == 3), replace = TRUE, prob = pmat[3,])
  
  index <- (X - 1) * 3 + V
  tabs <- tabulate(index, nbins = 9)
  names(tabs) <- c("MM", "MW", "MX",
                   "WM", "WW", "WX",
                   "XM", "XW", "XX")
  list("X" = X, "V" = V, "counts" = tabs)
}

#' Run a single repetition of a cell 
#'
#' @param cell A list of simulation parameters generated by make_cell.
#' @param pmat A transition matrix generated by make_pmat.
#' @param y A vector of response values.
#' @param design_mat A design matrix.
#'
#' @return A list containing the coefficients from the active and observed
#' linear models and category counts.
run_rep <- function(cell, pmat, design_mat, Y, verbose = FALSE) {
  categories <- make_xv(cell$n, cell$probs, pmat)
  colnames(design_mat) <- c("ACT_INT", "ACT_Z", "ACT_XW", "ACT_XX")
  design_mat[,2] <- make_z(categories$X, cell$delta)
  design_mat[,3] <- categories$X == 2
  design_mat[,4] <- categories$X == 3
  Y <- (design_mat %*% cell$beta) + rnorm(cell$n, sd = cell$sigma)
  mod_act <- lm.fit(design_mat, Y)$coefficients
  if (verbose) print(summary(design_mat))
  colnames(design_mat) <- c("OBS_INT", "OBS_Z", "OBS_XW", "OBS_XX")
  design_mat[,3] <- categories$V == 2
  design_mat[,4] <- categories$V == 3
  mod_obs <- lm.fit(design_mat, Y)$coefficients
  if (verbose) print(summary(design_mat))
  list2(
    !!!mod_act,
    !!!mod_obs,
    !!!categories$counts
  )
}

#' Run a set number of repetitions for a cell
#'
#' @param cell A list of simulation parameters generated by make_cell.
#' @param pmat A transition matrix generated by make_pmat.
#' @param reps Number of repetitions to run.
#'
#' @return A list of results from each repetition.
run_cell <- function(cell, pmat, reps = 1, verbose = FALSE) {
  Y <- rep(0, cell$n)
  design_mat <- matrix(c(rep(1, cell$n), rep(0, cell$n * 3)), nrow = cell$n)
  loop <- foreach(
    1:reps,
    .options.RNG = 420
  )
  result <- if (getDoParRegistered()) {
    loop %dorng% run_rep(cell, pmat, design_mat, Y, verbose)
  } else {
    loop %do% run_rep(cell, pmat, design_mat, Y, verbose)
  }
  map(result, \(x) as_tibble_row(x)) |>
    list_rbind()
}


# 