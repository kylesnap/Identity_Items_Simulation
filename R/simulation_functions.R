library(tidyverse)
library(checkmate)
library(rlang)
library(doRNG)
library(doParallel)

#' Make cell of simulation parameters
#'
#' @param n Number of observations.
#' @param probs A numeric vector of length 2 representing the probabilities of
#' each state: Pr_M (probability of state M), Pr_W (probability of state W),
#' and Pr_X (probability of state X).
#' @param beta A numeric vector of length 4 representing the coefficients for
#' the linear model: intercept, Z, XW, XX.
#' @param delta A numeric vector of length 2 representing the delta values for
#' each state: D_M (delta for state M), D_W (delta for state W), and D_X
#' (delta for state X).
#' @param sigma Standard deviation of the error term.
#'
#' @return A list containing the simulation parameters.
make_cell <- function(N,
                      probs,
                      betas = c("Int" = 0, "Z" = 0, "XW" = 0, "XX" = 0),
                      deltas = c("W" = 0, "X" = 0), 
                      Sigma_E = 1
                      ) {
  assert_numeric(
    probs,
    lower = 0,
    upper = 1,
    len = 3,
    any.missing = FALSE,
    names = "named"
  )
  assert(sum(probs) == 1)
  probs <- set_names(probs, \(x) paste0("Pr_", x))
  
  assert_numeric(
    betas,
    lower = 0,
    upper = 1,
    len = 4,
    any.missing = FALSE,
    names = "named"
  )
  betas <- set_names(betas, \(x) paste0("B_", x))
  
  assert_numeric(
    deltas,
    lower = 0,
    upper = 1,
    len = 2,
    any.missing = FALSE,
    names = "named"
  )
  deltas <- set_names(deltas, \(x) paste0("D_", x))
  
  assert_count(N)
  assert_number(Sigma_E, lower = .Machine$double.xmin)
  
  dm <- (-(deltas["D_W"] * probs["Pr_W"] + deltas["D_X"] * probs["Pr_X"]) / (1 - probs["Pr_W"] - probs["Pr_X"]))[[1]]
  list2(
    "n" = assert_count(N),
    !!!probs,
    !!!betas,
    "D_M" = dm,
    !!!deltas,
    "sigma" = Sigma_E
  )
}

#' Make a transition matrix for respondents
#'
#' @param ep_M A numeric vector of length 2 representing the transition
#' probabilities for state M.
#' @param ep_W A numeric vector of length 2 representing the transition
#' probabilities for state W.
#' @param ep_X A numeric vector of length 2 representing the transition
#' probabilities for state X.
#'
#' @return A transition matrix.
make_pmat <- function(row_M, row_W, row_X) {
  assert_numeric(
    row_M,
    lower = 0,
    upper = 1,
    len = 3,
    any.missing = FALSE
  )
  assert_numeric(
    row_W,
    lower = 0,
    upper = 1,
    len = 3,
    any.missing = FALSE
  )
  assert_numeric(
    row_X,
    lower = 0,
    upper = 1,
    len = 3,
    any.missing = FALSE
  )
  assert(sum(row_M) == 1)
  assert(sum(row_W) == 1)
  assert(sum(row_X) == 1)
  matrix(
    c(row_M, row_W, row_X),
    nrow = 3,
    byrow = TRUE,
    dimnames = list(c("X=M","X=W","X=X"), c("V=M","V=W","V=X"))
  )
}

#' Generate observations of the Z variable, conditional on X
#'
#' @param X A vector of X values.
#' @param deltas A named numeric vector of mean Z values for each state.
#'
#' @return A vector of observations of the Z variable.
make_z <- function(X, deltas) {
  Z <- numeric(length(X))
  Z[X == 1] <- rnorm(n = sum(X == 1), mean = deltas["D_M"], sd = 1)
  Z[X == 2] <- rnorm(n = sum(X == 2), mean = deltas["D_W"], sd = 1)
  Z[X == 3] <- rnorm(n = sum(X == 3), mean = deltas["D_X"], sd = 1)
  return(Z)
}

make_xv <- function(n, probs, pmat) {
  X <- sample.int(3, size = n, replace = TRUE, prob = probs)
  V <- integer(n)
  V[X == 1] <- sample.int(3, size = sum(X == 1), replace = TRUE, prob = pmat[1,])
  V[X == 2] <- sample.int(3, size = sum(X == 2), replace = TRUE, prob = pmat[2,])
  V[X == 3] <- sample.int(3, size = sum(X == 3), replace = TRUE, prob = pmat[3,])
  
  index <- (X - 1) * 3 + V
  tabs <- tabulate(index, nbins = 9)
  names(tabs) <- c("MM", "MW", "MX",
                   "WM", "WW", "WX",
                   "XM", "XW", "XX")
  list("X" = X, "V" = V, "counts" = tabs)
}

#' Run a single repetition of a cell 
#'
#' @param cell A list of simulation parameters generated by make_cell.
#' @param pmat A transition matrix generated by make_pmat.
#' @param y A vector of response values.
#' @param design_mat A design matrix.
#'
#' @return A list containing the coefficients from the active and observed
#' linear models and category counts.
run_rep <- function(cell, pmat, design_mat, Y, verbose = FALSE) {
  categories <- make_xv(cell$n, cell$probs, pmat)
  colnames(design_mat) <- c("ACT_INT", "ACT_Z", "ACT_XW", "ACT_XX")
  design_mat[,2] <- make_z(categories$X, cell$delta)
  design_mat[,3] <- categories$X == 2
  design_mat[,4] <- categories$X == 3
  Y <- (design_mat %*% cell$beta) + rnorm(cell$n, sd = cell$sigma)
  mod_act <- lm.fit(design_mat, Y)$coefficients
  if (verbose) print(summary(design_mat))
  colnames(design_mat) <- c("OBS_INT", "OBS_Z", "OBS_XW", "OBS_XX")
  design_mat[,3] <- categories$V == 2
  design_mat[,4] <- categories$V == 3
  mod_obs <- lm.fit(design_mat, Y)$coefficients
  if (verbose) print(summary(design_mat))
  list2(
    !!!mod_act,
    !!!mod_obs,
    !!!categories$counts
  )
}

#' Run a set number of repetitions for a cell
#'
#' @param cell A list of simulation parameters generated by make_cell.
#' @param pmat A transition matrix generated by make_pmat.
#' @param reps Number of repetitions to run.
#'
#' @return A list of results from each repetition.
run_cell <- function(cell, pmat, reps = 1, verbose = FALSE) {
  Y <- rep(0, cell$n)
  design_mat <- matrix(c(rep(1, cell$n), rep(0, cell$n * 3)), nrow = cell$n)
  loop <- foreach(
    1:reps,
    .options.RNG = 420
  )
  result <- if (getDoParRegistered()) {
    loop %dorng% run_rep(cell, pmat, design_mat, Y, verbose)
  } else {
    loop %do% run_rep(cell, pmat, design_mat, Y, verbose)
  }
  map(result, \(x) as_tibble_row(x)) |>
    list_rbind()
}


# 