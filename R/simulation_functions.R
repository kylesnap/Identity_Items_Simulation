library(tidyverse)
library(checkmate)
library(rlang)
library(doRNG)
library(doParallel)

#' Make cell of simulation parameters
#'
#' @param n Number of observations.
#' @param probs A numeric vector of length 2 representing the probabilities of
#' each state: Pr_M (probability of state M), Pr_W (probability of state W),
#' and Pr_X (probability of state X).
#' @param beta A numeric vector of length 4 representing the coefficients for
#' the linear model: intercept, Z, XW, XX.
#' @param delta A numeric vector of length 2 representing the delta values for
#' each state: D_M (delta for state M), D_W (delta for state W), and D_X
#' (delta for state X).
#' @param sigma Standard deviation of the error term.
#'
#' @return A list containing the simulation parameters.
make_cell <- function(n, probs, beta, delta, sigma) {
  assert_numeric(
    probs,
    lower = 0,
    upper = 1,
    len = 2,
    any.missing = FALSE
  )
  assert_numeric(beta, len = 4)
  assert_numeric(delta, len = 2)
  assert(probs[1] + probs[2] <= 1)
  list(
    "n" = assert_count(n),
    "probs" = c(
      "Pr_M" = 1 - probs[1] - probs[2],
      "Pr_W" = probs[1],
      "Pr_X" = probs[2]
    ),
    "beta" = c(
      "int" = beta[1],
      "Z" = beta[2],
      "XW" = beta[3],
      "XX" = beta[4]
    ),
    "delta" = c(
      "D_M" = -(delta[1] * probs[1] + delta[2] * probs[2]) / 
        (1 - probs[1] - probs[2]),
      "D_W" = delta[1],
      "D_X" = delta[2]
    ),
    "sigma" = assert_number(sigma, lower = .Machine$double.xmin)
  )
}

#' Make a transition matrix for respondents
#'
#' @param ep_M A numeric vector of length 2 representing the transition
#' probabilities for state M.
#' @param ep_W A numeric vector of length 2 representing the transition
#' probabilities for state W.
#' @param ep_X A numeric vector of length 2 representing the transition
#' probabilities for state X.
#'
#' @return A transition matrix.
make_pmat <- function(ep_M, ep_W, ep_X) {
  assert_numeric(
    ep_M,
    lower = 0,
    upper = 1,
    len = 2,
    any.missing = FALSE
  )
  assert_numeric(
    ep_W,
    lower = 0,
    upper = 1,
    len = 2,
    any.missing = FALSE
  )
  assert_numeric(
    ep_X,
    lower = 0,
    upper = 1,
    len = 2,
    any.missing = FALSE
  )
  assert(sum(ep_M) <= 1)
  assert(sum(ep_W) <= 1)
  assert(sum(ep_X) <= 1)
  matrix(
    c(1 - sum(ep_M),  ep_M[1], ep_M[2],
      ep_W[1], 1 - sum(ep_W), ep_W[2],
      ep_X[1], ep_X[2], 1 - sum(ep_X)
    ),
    nrow = 3,
    byrow = TRUE
  )
}

#' Generate observations of the Z variable, conditional on X
#'
#' @param X A vector of X values.
#' @param deltas A named numeric vector of mean Z values for each state.
#'
#' @return A vector of observations of the Z variable.
make_z <- function(X, deltas) {
  from_M <- rnorm(length(X), mean = deltas["D_M"], sd = 1)
  from_W <- rnorm(length(X), mean = deltas["D_W"], sd = 1)
  from_X <- rnorm(length(X), mean = deltas["D_X"], sd = 1)
  from_M * (X == 1) + from_W * (X == 2) + from_X * (X == 3)
}

make_xv <- function(n, probs, pmat) {
  X <- sample.int(3, size = n, replace = TRUE, prob = probs)
  from_M <- sample.int(3, size = n, replace = TRUE, prob = pmat[1,])
  from_W <- sample.int(3, size = n, replace = TRUE, prob = pmat[2,])
  from_X <- sample.int(3, size = n, replace = TRUE, prob = pmat[3,])
  V <- from_M * (X == 1) + from_W * (X == 2) + from_X * (X == 3)
  counts <- list(
    "MM" = sum((X == 1) * (V == 1)),
    "MW" = sum((X == 1) * (V == 2)),
    "MX" = sum((X == 1) * (V == 3)),
    "WM" = sum((X == 2) * (V == 1)),
    "WW" = sum((X == 2) * (V == 2)),
    "WX" = sum((X == 2) * (V == 3)),
    "XM" = sum((X == 3) * (V == 1)),
    "XW" = sum((X == 3) * (V == 2)),
    "XX" = sum((X == 3) * (V == 3))
  )
  list("X" = X, "V" = V, "counts" = counts)
}

#' Run a single repetition of a cell 
#'
#' @param cell A list of simulation parameters generated by make_cell.
#' @param pmat A transition matrix generated by make_pmat.
#' @param y A vector of response values.
#' @param design_mat A design matrix.
#'
#' @return A list containing the coefficients from the active and observed
#' linear models and category counts.
run_rep <- function(cell, pmat) {
  Y <- rep(0, cell$n)
  design_mat <- matrix(c(rep(1, cell$n), rep(0, cell$n * 3)), nrow = cell$n)
  categories <- make_xv(cell$n, cell$probs, pmat)
  colnames(design_mat) <- c("ACT_INT", "ACT_Z", "ACT_XW", "ACT_XX")
  design_mat[,2] <- make_z(categories$X, cell$delta)
  design_mat[,3] <- categories$X == 2
  design_mat[,4] <- categories$X == 3
  Y <- (design_mat %*% cell$beta) + rnorm(cell$n, sd = cell$sigma)
  mod_act <- lm.fit(design_mat, Y)$coefficients
  colnames(design_mat) <- c("OBS_INT", "OBS_Z", "OBS_XW", "OBS_XX")
  design_mat[,3] <- categories$V == 2
  design_mat[,4] <- categories$V == 3
  mod_obs <- lm.fit(design_mat, Y)$coefficients
  list2(
    !!!mod_act,
    !!!mod_obs,
    !!!categories$counts
  )
}

#' Run a set number of repetitions for a cell
#'
#' @param cell A list of simulation parameters generated by make_cell.
#' @param pmat A transition matrix generated by make_pmat.
#' @param reps Number of repetitions to run.
#'
#' @return A list of results from each repetition.
run_cell <- function(cell, pmat, reps = 1) {
  loop <- foreach(
    1:reps,
    .options.RNG = 420
  )
  result <- if (getDoParRegistered()) {
    loop %dorng% run_rep(cell, pmat)
  } else {
    loop %do% run_rep(cell, pmat)
  }
}
